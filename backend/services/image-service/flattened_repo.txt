<repository/image_repo.go>
package repository

import (
	"image-service/models"
	"os"
	"path/filepath"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

type ImageRepo struct {
	DB *gorm.DB
}

func NewImageRepo() *ImageRepo {
	dsn := os.Getenv("DATABASE_DSN")
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		panic("‚ùå Failed to connect to database: " + err.Error())
	}

	if err := db.AutoMigrate(&models.Image{}); err != nil {
		panic("‚ùå AutoMigrate failed: " + err.Error())
	}

	return &ImageRepo{DB: db}
}

func (r *ImageRepo) Save(image *models.Image) error {
	return r.DB.Create(image).Error
}

func (r *ImageRepo) Get(id string) (*models.Image, error) {
	var img models.Image
	err := r.DB.First(&img, "id = ?", id).Error
	if err != nil {
		return nil, err
	}
	return &img, nil
}

func (r *ImageRepo) Delete(id string) error {
	img, err := r.Get(id)
	if err != nil {
		return err
	}

	// Delete image file from disk
	if img.FileName != "" {
		fullPath := filepath.Join("uploads", img.FileName)
		if err := os.Remove(fullPath); err != nil && !os.IsNotExist(err) {
			return err
		}
	}

	// Delete DB record
	return r.DB.Delete(&models.Image{}, "id = ?", id).Error
}

</repository/image_repo.go>

<handlers/image_handler.go>
package handlers

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"image-service/models"
	"image-service/proto"
	"image-service/repository"

	"github.com/google/uuid"
)

type ImageService struct {
	proto.UnimplementedImageServiceServer
	Repo *repository.ImageRepo
}

func (s *ImageService) UploadImage(ctx context.Context, req *proto.UploadImageRequest) (*proto.UploadImageResponse, error) {
	id := uuid.New().String()
	ext := ".jpg" // You can enhance this by parsing from req.FileType
	fileName := id + ext
	filePath := filepath.Join("uploads", fileName)

	// Save to disk
	if err := os.WriteFile(filePath, req.ImageData, 0644); err != nil {
		log.Printf("‚ùå Failed to save image: %v", err)
		return nil, err
	}

	image := &models.Image{
		ID:         id,
		EntityID:   req.EntityId,
		EntityType: req.EntityType,
		FileType:   req.FileType,
		FileName:   fileName, // ‚úÖ Save only filename
	}

	if err := s.Repo.Save(image); err != nil {
		log.Printf("‚ùå Failed to save image metadata: %v", err)
		return nil, err
	}

	log.Printf("‚úÖ Uploaded image: ID=%s, saved to %s", id, filePath)
	return &proto.UploadImageResponse{ImageId: id}, nil
}

func (s *ImageService) GetImage(ctx context.Context, req *proto.GetImageRequest) (*proto.GetImageResponse, error) {
	img, err := s.Repo.Get(req.ImageId)
	if err != nil {
		log.Printf("‚ùå Failed to fetch image: %v", err)
		return nil, err
	}

	fullPath := filepath.Join("uploads", img.FileName)
	data, err := os.ReadFile(fullPath)
	fmt.Println("image data", data)
	if err != nil {
		log.Printf("‚ùå Failed to read image from disk: %v", err)
		return nil, err
	}

	return &proto.GetImageResponse{
		ImageData: data,
		FileType:  img.FileType,
	}, nil
}

func (s *ImageService) DeleteImage(ctx context.Context, req *proto.DeleteImageRequest) (*proto.DeleteImageResponse, error) {
	if err := s.Repo.Delete(req.ImageId); err != nil {
		log.Printf("‚ùå Failed to delete image: %v", err)
		return nil, err
	}

	return &proto.DeleteImageResponse{Status: "deleted"}, nil
}

</handlers/image_handler.go>

<models/image.go>
package models

type Image struct {
	ID         string `gorm:"primaryKey"`
	EntityID   string
	EntityType string
	FileType   string
	FileName   string // ‚úÖ Store only file name like "abc.jpg"
}

</models/image.go>

<main.go>
package main

import (
	"image-service/handlers"
	"image-service/proto"
	"image-service/repository"
	"log"
	"net"

	"github.com/joho/godotenv"
	"google.golang.org/grpc"
)

func main() {
	_ = godotenv.Load("../.env")
	repo := repository.NewImageRepo()
	grpcServer := grpc.NewServer()
	proto.RegisterImageServiceServer(grpcServer, &handlers.ImageService{Repo: repo})

	lis, err := net.Listen("tcp", ":50054")
	if err != nil {
		log.Fatal("Failed to listen:", err)
	}

	log.Println("üì∑ Image Service running on :50054")
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatal("Failed to serve:", err)
	}
}

</main.go>

<proto/image_grpc.pb.go>
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: proto/image.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ImageService_UploadImage_FullMethodName = "/image.ImageService/UploadImage"
	ImageService_GetImage_FullMethodName    = "/image.ImageService/GetImage"
	ImageService_DeleteImage_FullMethodName = "/image.ImageService/DeleteImage"
)

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImageServiceClient interface {
	UploadImage(ctx context.Context, in *UploadImageRequest, opts ...grpc.CallOption) (*UploadImageResponse, error)
	GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*GetImageResponse, error)
	DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*DeleteImageResponse, error)
}

type imageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageServiceClient(cc grpc.ClientConnInterface) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) UploadImage(ctx context.Context, in *UploadImageRequest, opts ...grpc.CallOption) (*UploadImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadImageResponse)
	err := c.cc.Invoke(ctx, ImageService_UploadImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*GetImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetImageResponse)
	err := c.cc.Invoke(ctx, ImageService_GetImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*DeleteImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteImageResponse)
	err := c.cc.Invoke(ctx, ImageService_DeleteImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
// All implementations must embed UnimplementedImageServiceServer
// for forward compatibility.
type ImageServiceServer interface {
	UploadImage(context.Context, *UploadImageRequest) (*UploadImageResponse, error)
	GetImage(context.Context, *GetImageRequest) (*GetImageResponse, error)
	DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageResponse, error)
	mustEmbedUnimplementedImageServiceServer()
}

// UnimplementedImageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImageServiceServer struct{}

func (UnimplementedImageServiceServer) UploadImage(context.Context, *UploadImageRequest) (*UploadImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadImage not implemented")
}
func (UnimplementedImageServiceServer) GetImage(context.Context, *GetImageRequest) (*GetImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImage not implemented")
}
func (UnimplementedImageServiceServer) DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (UnimplementedImageServiceServer) mustEmbedUnimplementedImageServiceServer() {}
func (UnimplementedImageServiceServer) testEmbeddedByValue()                      {}

// UnsafeImageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageServiceServer will
// result in compilation errors.
type UnsafeImageServiceServer interface {
	mustEmbedUnimplementedImageServiceServer()
}

func RegisterImageServiceServer(s grpc.ServiceRegistrar, srv ImageServiceServer) {
	// If the following call pancis, it indicates UnimplementedImageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImageService_ServiceDesc, srv)
}

func _ImageService_UploadImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).UploadImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_UploadImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).UploadImage(ctx, req.(*UploadImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_GetImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).GetImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_GetImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).GetImage(ctx, req.(*GetImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_DeleteImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).DeleteImage(ctx, req.(*DeleteImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImageService_ServiceDesc is the grpc.ServiceDesc for ImageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "image.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadImage",
			Handler:    _ImageService_UploadImage_Handler,
		},
		{
			MethodName: "GetImage",
			Handler:    _ImageService_GetImage_Handler,
		},
		{
			MethodName: "DeleteImage",
			Handler:    _ImageService_DeleteImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/image.proto",
}

</proto/image_grpc.pb.go>

<proto/image.pb.go>
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.12.4
// source: proto/image.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UploadImageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	EntityId      string                 `protobuf:"bytes,1,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	EntityType    string                 `protobuf:"bytes,2,opt,name=entity_type,json=entityType,proto3" json:"entity_type,omitempty"` // "product" or "profile"
	ImageData     []byte                 `protobuf:"bytes,3,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`
	FileType      string                 `protobuf:"bytes,4,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"` // "image/png", etc.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadImageRequest) Reset() {
	*x = UploadImageRequest{}
	mi := &file_proto_image_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadImageRequest) ProtoMessage() {}

func (x *UploadImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_image_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadImageRequest.ProtoReflect.Descriptor instead.
func (*UploadImageRequest) Descriptor() ([]byte, []int) {
	return file_proto_image_proto_rawDescGZIP(), []int{0}
}

func (x *UploadImageRequest) GetEntityId() string {
	if x != nil {
		return x.EntityId
	}
	return ""
}

func (x *UploadImageRequest) GetEntityType() string {
	if x != nil {
		return x.EntityType
	}
	return ""
}

func (x *UploadImageRequest) GetImageData() []byte {
	if x != nil {
		return x.ImageData
	}
	return nil
}

func (x *UploadImageRequest) GetFileType() string {
	if x != nil {
		return x.FileType
	}
	return ""
}

type UploadImageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageId       string                 `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadImageResponse) Reset() {
	*x = UploadImageResponse{}
	mi := &file_proto_image_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadImageResponse) ProtoMessage() {}

func (x *UploadImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_image_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadImageResponse.ProtoReflect.Descriptor instead.
func (*UploadImageResponse) Descriptor() ([]byte, []int) {
	return file_proto_image_proto_rawDescGZIP(), []int{1}
}

func (x *UploadImageResponse) GetImageId() string {
	if x != nil {
		return x.ImageId
	}
	return ""
}

type GetImageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageId       string                 `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetImageRequest) Reset() {
	*x = GetImageRequest{}
	mi := &file_proto_image_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetImageRequest) ProtoMessage() {}

func (x *GetImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_image_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetImageRequest.ProtoReflect.Descriptor instead.
func (*GetImageRequest) Descriptor() ([]byte, []int) {
	return file_proto_image_proto_rawDescGZIP(), []int{2}
}

func (x *GetImageRequest) GetImageId() string {
	if x != nil {
		return x.ImageId
	}
	return ""
}

type GetImageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageData     []byte                 `protobuf:"bytes,1,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`
	FileType      string                 `protobuf:"bytes,2,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetImageResponse) Reset() {
	*x = GetImageResponse{}
	mi := &file_proto_image_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetImageResponse) ProtoMessage() {}

func (x *GetImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_image_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetImageResponse.ProtoReflect.Descriptor instead.
func (*GetImageResponse) Descriptor() ([]byte, []int) {
	return file_proto_image_proto_rawDescGZIP(), []int{3}
}

func (x *GetImageResponse) GetImageData() []byte {
	if x != nil {
		return x.ImageData
	}
	return nil
}

func (x *GetImageResponse) GetFileType() string {
	if x != nil {
		return x.FileType
	}
	return ""
}

type DeleteImageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageId       string                 `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteImageRequest) Reset() {
	*x = DeleteImageRequest{}
	mi := &file_proto_image_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteImageRequest) ProtoMessage() {}

func (x *DeleteImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_image_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteImageRequest.ProtoReflect.Descriptor instead.
func (*DeleteImageRequest) Descriptor() ([]byte, []int) {
	return file_proto_image_proto_rawDescGZIP(), []int{4}
}

func (x *DeleteImageRequest) GetImageId() string {
	if x != nil {
		return x.ImageId
	}
	return ""
}

type DeleteImageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteImageResponse) Reset() {
	*x = DeleteImageResponse{}
	mi := &file_proto_image_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteImageResponse) ProtoMessage() {}

func (x *DeleteImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_image_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteImageResponse.ProtoReflect.Descriptor instead.
func (*DeleteImageResponse) Descriptor() ([]byte, []int) {
	return file_proto_image_proto_rawDescGZIP(), []int{5}
}

func (x *DeleteImageResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

var File_proto_image_proto protoreflect.FileDescriptor

const file_proto_image_proto_rawDesc = "" +
	"\n" +
	"\x11proto/image.proto\x12\x05image\"\x8e\x01\n" +
	"\x12UploadImageRequest\x12\x1b\n" +
	"\tentity_id\x18\x01 \x01(\tR\bentityId\x12\x1f\n" +
	"\ventity_type\x18\x02 \x01(\tR\n" +
	"entityType\x12\x1d\n" +
	"\n" +
	"image_data\x18\x03 \x01(\fR\timageData\x12\x1b\n" +
	"\tfile_type\x18\x04 \x01(\tR\bfileType\"0\n" +
	"\x13UploadImageResponse\x12\x19\n" +
	"\bimage_id\x18\x01 \x01(\tR\aimageId\",\n" +
	"\x0fGetImageRequest\x12\x19\n" +
	"\bimage_id\x18\x01 \x01(\tR\aimageId\"N\n" +
	"\x10GetImageResponse\x12\x1d\n" +
	"\n" +
	"image_data\x18\x01 \x01(\fR\timageData\x12\x1b\n" +
	"\tfile_type\x18\x02 \x01(\tR\bfileType\"/\n" +
	"\x12DeleteImageRequest\x12\x19\n" +
	"\bimage_id\x18\x01 \x01(\tR\aimageId\"-\n" +
	"\x13DeleteImageResponse\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status2\xd7\x01\n" +
	"\fImageService\x12D\n" +
	"\vUploadImage\x12\x19.image.UploadImageRequest\x1a\x1a.image.UploadImageResponse\x12;\n" +
	"\bGetImage\x12\x16.image.GetImageRequest\x1a\x17.image.GetImageResponse\x12D\n" +
	"\vDeleteImage\x12\x19.image.DeleteImageRequest\x1a\x1a.image.DeleteImageResponseB\x15Z\x13image-service/protob\x06proto3"

var (
	file_proto_image_proto_rawDescOnce sync.Once
	file_proto_image_proto_rawDescData []byte
)

func file_proto_image_proto_rawDescGZIP() []byte {
	file_proto_image_proto_rawDescOnce.Do(func() {
		file_proto_image_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_image_proto_rawDesc), len(file_proto_image_proto_rawDesc)))
	})
	return file_proto_image_proto_rawDescData
}

var file_proto_image_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_proto_image_proto_goTypes = []any{
	(*UploadImageRequest)(nil),  // 0: image.UploadImageRequest
	(*UploadImageResponse)(nil), // 1: image.UploadImageResponse
	(*GetImageRequest)(nil),     // 2: image.GetImageRequest
	(*GetImageResponse)(nil),    // 3: image.GetImageResponse
	(*DeleteImageRequest)(nil),  // 4: image.DeleteImageRequest
	(*DeleteImageResponse)(nil), // 5: image.DeleteImageResponse
}
var file_proto_image_proto_depIdxs = []int32{
	0, // 0: image.ImageService.UploadImage:input_type -> image.UploadImageRequest
	2, // 1: image.ImageService.GetImage:input_type -> image.GetImageRequest
	4, // 2: image.ImageService.DeleteImage:input_type -> image.DeleteImageRequest
	1, // 3: image.ImageService.UploadImage:output_type -> image.UploadImageResponse
	3, // 4: image.ImageService.GetImage:output_type -> image.GetImageResponse
	5, // 5: image.ImageService.DeleteImage:output_type -> image.DeleteImageResponse
	3, // [3:6] is the sub-list for method output_type
	0, // [0:3] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_proto_image_proto_init() }
func file_proto_image_proto_init() {
	if File_proto_image_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_image_proto_rawDesc), len(file_proto_image_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_image_proto_goTypes,
		DependencyIndexes: file_proto_image_proto_depIdxs,
		MessageInfos:      file_proto_image_proto_msgTypes,
	}.Build()
	File_proto_image_proto = out.File
	file_proto_image_proto_goTypes = nil
	file_proto_image_proto_depIdxs = nil
}

</proto/image.pb.go>

